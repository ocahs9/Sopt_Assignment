/*렌더링할 때, 사진 잠깐 로딩되느라 빈칸 보이는데
그것마저 없앨 방법은 없을까?*/

/*그리고, 한번 맨 위의 상단바를 fix해두면 
모든 이웃요소들을 상단바의 height만큼 아래로 움직여야하나? */

/*배너리스트 겹칩 문제 어떻게 해결? */

/*사이드바를 fixed해두고, flex 박스도 그에 맞게 크기와 위치를 조절했는데,
직접 하는 방법 말고 자연스럽게 배치하는 방법은 없나? 
fixed는 아마 relative와는 거리 계산을 안한다.*/

/*fixed, abs 는 문서 흐름에서 완전 벗어난다
relative는 다른 static 요소에 의해 최초 위치가 결정되며, 다른 요소들의 위치에 영향을 주진 않는다.
*/

*{
  box-sizing: border-box; /*사이즈 계산 편리*/

  /*기본값으로 모든 요소 마진과 패딩 없앰*/
  margin: 0px;
  padding: 0px; 
}
a{
  text-decoration: none;
  color: black; /*방문하기 전의 기본 색깔*/
}
a:visited{
  color:black;
}

ul{
  list-style: none;
}

img{
  display: inline-block;
  height: 100%;
  width: auto;
}

/**********************
 header부분 구현 
**********************/
header{
  position: fixed;
  display: flex;
  flex-wrap: wrap; /*당장은 필요없음*/
  justify-content: space-between;
  align-items: center;
  z-index: 1; /*우선순위 - 앞에 먼저 나오도록 함*/
  width: 100%; /*width 부모요소만큼(전체) 차지*/
  height: 50px;
  background-color: greenyellow;
}

.fa-house, .fa-bars{
  font-size: 20px;
  margin-left: 10px;
  margin-right: 10px;
}



/**********************
 main부분 구현 
**********************/
main{
  position: relative; 
  top: 50px;
  width:100%;
  min-height: calc(100vh - 50px); /*기본적인 크기 정의 (정의 안해두면 자식요소들이 있는만큼만 차지하기 때문*/
  background-color: rgba(255, 192, 203, 0.2);
}


/****nav 구현 *******/
.sideNav{
  position: fixed;  /*nav bar 위치 고정 및 지정*/
  top:300px;
  left:10px;
  z-index: 1;

  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;

  width: 180px;
  height: 300px;
  border: 3px pink solid;
  background-color: bisque;
  border-radius: 1rem;
}
.sideNav h3{
  margin-top: 10px;
  font-size: 18px;
}

.sideNav ul{
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  align-items: center;

  margin-top: 20px;
  width: 180px;
  height: 200px;
  
  font-weight: bold;
  font-size: 14px;
  background-color: violet;
  border: 3px pink solid;
  border-radius: .25rem;
}

.sideNav ul li{
  background-color: inherit;
  width: 90%;
  height: 30px;
  text-align: center;
  line-height: 30px;
}

.sideNav ul li:hover{
  background-color: aliceblue;
  color: rgb(158, 21, 158);
  text-shadow: 0 0 10px rgba(0, 0, 0, 0.7); /*수평, 수직, 흐림정도(퍼지는), 색*/
}


.sideNav ul li a{ /*중요! 여기서 a의 컬러색을 부모의 컬러 정의로부터 가져와서 변하도록 한다.*/
  color: inherit; /*inherit을 통해, 부모 요소가 변할 때 그 색을 따라간다*/
} /*이렇게 해야 list와 a의 색이 동시에 변한다*/

.sideModal {
  position: fixed;  /*nav bar 위치 고정 및 지정*/
  top:0px;
  right: -180px;  /*초기엔 바깥에 있어서 안보이게 만듬*/
  z-index: 1;

  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: flex-start;

  width: 180px;
  height: 100vh; /*전체 다 차도록*/
  padding-top: 10px;
  border: 3px solid;
  background-color: bisque;
  /*하나 더 깨달은 것은, 그라데이션을 넣으려면 -image를 사용해야한다는 것이다
    즉, background-image 에 그라데이션을 적용할 수 있지, -color에는 적용하지 못한다.
    아니면 backgroud (여러 속성 합쳐 쓰는 거)에다가 쓸 수도 있다. 
  */
  /*그러나 테두리는 border가 아닌 오직 border-image를 통해서만 가능하다.
    또한, slice 속성이 반드시 있어야 한다. 
    참고) 만약, 둥근 모서리에 그라데이션까지 적용하고 싶으면 다른 방법을 찾아야한다  
  */
  border-image:linear-gradient(to  bottom right ,#0060fd ,#03e6c8, #df30e2);
  border-image-slice:1; /*border-image를 얼마나 잘라 쓸지*/

  /*정상적인 사용 방식은 아닌 듯. 근데 지정하는 곳이 사라지길래 그냥 적용해봄*/
  border-top: none;
  border-right: none;
  border-bottom: none;
}
.sideModal .fa-arrow-right{
  margin-left: 10px;
  font-size: 20px; 
}

.sideModal ul{
  margin-top: 1vh;
  margin-left: 20px;
}

.sideModal ul li{
  margin-top: 1vh;
}

.sideModal ul li:hover{
  background-color: aliceblue;
  color: rgb(158, 21, 158);
  text-shadow: 0 0 10px rgba(0, 0, 0, 0.7); /*수평, 수직, 흐림정도(퍼지는), 색*/
}

.sideModal ul li a{
  color: inherit;
}

@keyframes closingModal{
  from{
    transform: translateX(-100%);
  }
  to{
    transform: translateX(0);
  }
}
.closingRight{
  animation: closingModal 0.5s linear forwards; /*forwards는 마지막 100% 상태를 유지하게 해주는 옵션*/
}

@keyframes openingModal {
  from{
    transform: translateX(0);
  }
  to{
    transform: translateX(-100%);
  }
}

.openingLeft{
  animation: openingModal 0.5s linear forwards;
}

#closeModal, #threeBar{
  cursor: pointer;
}
/*
  혹시 li태그를 눌러도 a의 기능이 나도록 할 수는 없을까?
  -> 단순하게 li 태그 바깥에 a태그로 둘렀는데 잘 안됨
*/
/********************/

/************slideShow 구현*************/
.slideWindow{
  position: static; /*기본 값, 일부러 relative에 영향을 준다는 것을 강조하려고 써둠*/
  
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  flex-wrap: nowrap;

  width: 100%;
  height: 200px;
  border: 2px dotted rgba(138, 218, 106, 0.7);

  overflow: hidden;
}

/***********문제 해결 ***********************/
.slideWindow .bannerList{
  display: flex; /*얘까지 해줘야 제대로 배너리스트가 들어감*/
  flex-wrap: nowrap; /*옆으로 가도록*/
  width: 105vw; /*100%에서 이미지의 크기 * 7개 = 105vw로 바꿈 - 문제 해결*/
  /*width : 100%나 100vw로 하면 문제점: 브라우저상 보이는 부분만 크기로 인식하여, 실제 잘려나가는 크기를 인식 못한다*/
  height: 100%;
}

/***********문제 해결 : 이제 아무리 창 크기를 줄여도 겹쳐지는 문제 안생김 ***********************/
/*img크기나 li크기를 %로 하는 것은 크게 문제가 되지 않음.
단지, 잘려나가는 요소(이번 경우에는 bannerList)의 크기만 확실하게 정해주면 됨.
단순하게 100%로 하면 자식 요소들의 합이 부모요소들을 넘어서는 걸 제어하기가 어려워짐
*/
.slideWindow .bannerList li{
  width:15vw;
  height:100%;
}

.slideWindow .bannerList img{
  width: 100%; /*문제점 : 창의 크기가 작아지면 짤리는대로 ...배너리스트가 되어 이상한게 루프된다*/
  height: 100%; /*li 안에 넣었으니까, 해당 높이 따라가게 해주어야함.*/
  /*그래서 vw를 사용하니 어느정도 문제가 해결!  -완전 해결은 아님*/
  /*창을 줄여도 유지 되도록 하고 싶은데.. 일단 배너리스트끼리 겹치는 문제가 해결되어야 한다 */
  object-fit: fill;
}

/*배너리스트 겹칩 문제 어떻게 해결? */
#banner1{
  animation: sliding1 12s linear infinite; /*12초간 sliding을 일정한 속도로 무한반복*/
}

#banner2{
  animation: sliding2 12s linear infinite; /*12초간 sliding을 일정한 속도로 무한반복*/
}

/*결국 아래의 코드에는 같은 걸 2번 써두긴 했지만, 여러가지 방식을 고민해봄
  1. 0, 50, 50.01, 100 과 같이 디테일하게 나누어서 해야하나?
  2. 그냥 배너 1,2 각자 다른 방식으로 움직이게 해야하나?
  3. 배너1,2 둘다 같은 방식으로 움직이게 해야하나?
*/
@keyframes sliding1{
  from{
    transform: translateX(0%);
  }
  to {
    transform: translateX(-100%); /*여기서 퍼센트는 해당 애니메이션의 x좌표 크기, 즉 width 크기를 기준으로 한다*/
  }
}

@keyframes sliding2{
  from{
    transform: translateX(0);
  }
  to {
    transform: translateX(-100%);
  }
}
/*************************************/

/****Section 구현 *******/


.flexSection{
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-items: center;

  position: relative;
  /*top:50px; 이거 있으면 안된다!! 바로 부모요소에서 50px 더 내려가기 때문에, 결국 부모요소의 높이를 넘어선다*/ 
  left: 210px;
  width: calc(100vw - 220px); /*width : 뷰포트 다 채우고, 왼쪽으로 움직이는 만큼 뺀 너비*/
  /*border: 3px solid black;*/
}

.flexSection h2{
  width: 100%; /*옆에 아무도 못 오게*/
  margin-left: 20px;
  margin-top: 50px; /*이름 안 가려지게(메뉴바에 의해)*/
  margin-bottom: 20px;
  font-size: 40px;
  color: black;
}

.flexSection .productCard{
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  line-height: 25px;

  width: 18%; /*대략 뷰 포트로 크기를 설정하여 최대 5개가 오도록 만듬 -> 근데, 뷰포트가 달라지면 더 많이 올 수도.. 따라서 그냥 부모요소의 크기를 기준으로 설정*/
  margin: 10px;
  
  border: paleturquoise 2px solid;
  
}

/*5개는 디폴트니까 따로 설정 안함*/
@media screen and (max-width: 1220px) {
  .flexSection .productCard {
    width: 22%; /* 4개의 요소가 보여짐 */
  }
}

/* 화면 너비가 900px 미만이 되면 */
@media screen and (max-width: 900px) {
  .flexSection .productCard {
    width: 28%; /* 3개의 요소가 보여짐 */
  }
}

/* 화면 너비가 700px 미만이 되면 */
@media screen and (max-width: 700px) {
  .flexSection .productCard {
    width: 40%; /* 2개의 요소만 보여짐 */
  }
}

/* 화면 너비가 600px 미만이 되면 */
@media screen and (max-width: 600px) {
  .flexSection .productCard {
    width: 90%; /* 1개의 요소가 보여짐 */
  }
}



/*내컴퓨터 대략 1750이 가장 큰 width (이거 어떻게 계산?

*/




.flexSection .productCard:hover{
  animation: boom 1s infinite linear; /*손댔을 때 자연스레 커졌다 작아졌다*/
}


@keyframes boom{
  0% {
    transform: scale(1); /*인자 하나만 주면, x-y쌍이 동시에 커짐 , 1이 기본값*/
  }

  50% {
    transform: scale(1.05);
  }

  100% {
    transform: scale(1);
  }
}

.flexSection .productCard img{
  width: 100%; /*부모요소 따라가도록 기본설정*/
}

.flexSection .productCard img.album{
  height: 310px;
}
.flexSection .productCard img.movie{
  height: 440px;
}
.flexSection .productCard img.travel{
  height: 200px;
}

.fa-heart:hover{ /*fontawesome 아이콘 커스텀*/
  color: red;
}

.productCard .fa-heart{ /*조금 떨어트려줌*/
  margin-top: 5px;
}

/**********************
 footer부분 구현 
**********************/
footer{
  position: relative;
  top:50px;
  width: 100%;
  height: 300px;

  background-color: aliceblue;
}



/* flex 안쓰고 정렬하는 방식(부모를 기준으로, 정 가운데로 움직임)*/
footer p {
  position: absolute; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 

  /*아니면 vertical-align을 footer에서 사용할 수도 있을 듯..?*/
}




/************ cart페이지 구현 **********/
#cartContainer{
  display: flex;
  flex-direction: column;
  align-items: center; /*테이블을 가운데에 배치하기 위해서*/
}

/*
  스크롤 생성을 위한 div.tableContainer !
  참고로 table 요소는 컨텐츠의 크기에 맞게 알아서 조절된다.
  다만, table의 크기를 고정하고 셀이 맞춰가거나
  아니면 특정 셀만 조금 크기를 조절하는 방법이 존재하긴 한다.
*/
.tableContainer {
  margin-top: 5vh;
  width:70vw;
  max-height: 60vh; /*40vh까진 스크롤 안 생기게 만듬*/

  overflow-y: scroll; /*tabel의 지정 height를 넘으면 scroll 생성*/

  border-collapse: collapse;
  border: 2px solid rgb(140 140 140);
  font-family: sans-serif;
  font-size: 0.8rem;
  letter-spacing: 1px;

  /*스크롤바도 스타일링하고 싶은데 그건 좀 나중에...*/
}



/* 사용안함 -> 
.tableContainer .cartTable{
  table-layout:fixed;
  width: 100%;
}
https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout 
*/

/*
  셀 크기를 아무리 정해봤자, 결국 콘텐츠의 크기가 넘쳐나면 그만큼 늘어난다.
  그러나, 이를 조금 조절할 수 있는 방법은, 콘텐츠의 크기를 부모 요소의 크기를 따라가게
  width: 100%를 한 뒤, 셀의 width를 정해주는 것이다.
  아래의 경우 height는 일부로 정하지 않았는데, 만약 height를 설정한다면
  셀의 height가 셀 콘텐츠의 height 보다 클 땐 반영되고, 작을 땐 반영안된다.
  이 경우, img의 height: 100%로 해놓아서, 더 작게 해도 반영은 된다.
*/

/*구현 예시처럼 셀의 크기를 고정 시키는 방법은?*/
th,td {
  overflow: hidden;
  width: 16vw; /*일일히 다 재가면서 했는데,, 다른 방법은 없을까?*/
  height: 15vh;
  border: 1px solid rgb(160 160 160);
  padding: 8px 10px;
  text-align: center;
}

th.checkCol{
  width: 5vw;
}


.theadFix{
  position: sticky; /*사용하려면 부모태그에 height 값이 있어야 한다던데.. 왜 되는거지?*/
  top:0px;
  background-color: rgb(160 160 160);
}

.buyOrBack{
  position: relative; /*table요소가 커지면 그만큼 내려감*/
  top: 20vh;
}

.cartBtn{
  margin: 10px;
  display: inline-block;
  width: 5vw;

  border: #df30e2 1px solid;
  border-radius: 0.25rem;
}

.cartBtn:hover{
  background-color: pink;
}


.modalWrapper {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;

  position: fixed;
  top: 0; /*위에 딱 고정시킴.*/
  z-index: 1; /*더 앞에 나오도록 -> 근데 없어도 문제 없긴 함*/

  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0,0.5); /*반 투명.*/
}

.modal{
  position: relative;

  display: flex;
  flex-direction: column;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: flex-start;

  width: 50%;
  height: 50%;
  background-color: white;
  
  

  border-radius: 0.45rem;
  /*중심으로 부터 시작되고, 흐림정도가 다른 2개의 box-shadow 효과를 레이어로 활용*/
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), 0 0 40px rgba(66, 217, 55, 0.8);
}

#modalContent{
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;


  position: relative;
  top: 0; /*기본 맥락을 사용하기 위해 relative 활용*/

  width: 100%;
  height: 80%;
  overflow-y: scroll;
  
  /*코드 리뷰 받았던 거 다시 한번 사용해보기!*/
  border: 2px solid;
  border-image: linear-gradient(to bottom right, rgb(75, 207, 32), rgb(175, 205, 21), rgb(97, 161, 218));
  border-image-slice:1; /*border-image를 얼마나 잘라 쓸지*/
}

.closeDiv{
  position: relative; /* 참고- fixed와 absolute의 차이 : 뷰포트 기준인지 부모 기준인지*/
  right: 0.1em;

  width: 100%; 
  height: 1.5em;
  display: flex; 
  justify-content: flex-end;

  
}

.payDiv{
  position: relative;
  bottom: 0.5em;

  width: 100%; 
  display: flex; 
  justify-content: center;

  
}

.fa-square-xmark{

  font-size: 1.5em;
  cursor: pointer;
}

.rowFlexDiv{
  position: relative;

  display: flex;
  flex-direction: row;
  flex-wrap: nowrap; 
  justify-content: space-between;
  align-items: center;
  

  margin: 5px;
  
  width: 98%;
  height: 25%;
  border: 1px solid red;
}

#modalContent .rowFlexDiv img{
  width: 15%;

  border: 1px solid wheat;
}

.cartItemP{
  
  
  text-align: center;
  align-content: center; /*align-items와는 좀 다르다. 기능 자체나, 사용 방법이나..*/
}

#cartItemPrice{
  align-self:flex-end;
  /*align-self 속성을 활용하여 해결! 나중엔 그리드도 좀 연습해봐야겠다.*/
  /*position: absolute; 이거 화면 창 줄이면 겹쳐지는 문제 발생하는데 어떻게 해결하지?
  bottom: 0;
  right: 1em;
  */
  margin-right: 10px;
  margin-bottom: 5px;
  border: 1px dotted black;
  background-color: white;
}

#payBtn{
  border-radius: 0.25rem;
  width: 10%;
}

#payBtn:hover{
  background-color: pink;
  
}